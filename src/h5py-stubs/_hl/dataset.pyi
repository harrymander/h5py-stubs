from abc import ABC, abstractmethod
from typing import Any, Self

from numpy.typing import DTypeLike

from .base import HLObject

MPI: Any

class AbstractView(ABC):
    _dset: Dataset
    def __init__(self, dset) -> None: ...
    def __len__(self):  # -> int:
        ...
    @property
    @abstractmethod
    def dtype(self):  # -> None:
        ...
    @property
    def ndim(self): ...
    @property
    def shape(self): ...
    @property
    def size(self):  # -> Literal[1] | None:
        ...
    @abstractmethod
    def __getitem__(self, idx):  # -> None:
        ...
    def __array__(self, dtype=..., copy=...):  # -> NDArray[Any]:
        ...

class AsTypeView(AbstractView):
    def __init__(self, dset, dtype) -> None: ...
    @property
    def dtype(self):  # -> Any:
        ...
    def __getitem__(self, idx): ...
    def __array__(self, dtype=..., copy=...):  # -> _Array1D[float64]:
        ...

class AsStrView(AbstractView):
    def __init__(self, dset, encoding, errors=...) -> None: ...
    @property
    def dtype(self):  # -> dtype[object_ | Any]:
        ...
    def __getitem__(self, idx):  # -> str | NDArray[Any]:
        ...

class FieldsView(AbstractView):
    def __init__(self, dset, prior_dtype, names) -> None: ...
    @property
    def dtype(self):  # -> dtype[Any] | dtype[void]:
        ...
    def __getitem__(self, idx): ...

class CollectiveContext:
    def __init__(self, dset) -> None: ...
    def __enter__(self):  # -> None:
        ...
    def __exit__(self, *args):  # -> None:
        ...

class ChunkIterator:
    def __init__(self, dset, source_sel=...) -> None: ...
    def __iter__(self):  # -> Self:
        ...
    def __next__(self):  # -> tuple[Any, ...]:
        ...

class Dataset(HLObject):
    def astype(self, dtype: DTypeLike) -> Self | AsTypeView: ...
    def asstr(self, encoding=..., errors=...):  # -> AsStrView:
        ...
    def fields(self, names, *, _prior_dtype=...):  # -> FieldsView:
        ...
    @property
    def collective(self):  # -> CollectiveContext:
        ...
    @property
    def dims(self):  # -> DimensionManager:
        ...
    @property
    def ndim(self): ...
    @property
    def shape(self): ...
    @shape.setter
    def shape(self, shape):  # -> None:
        ...
    @property
    def size(self):  # -> Literal[1] | None:
        ...
    @property
    def nbytes(self):  # -> Literal[0]:
        ...
    @property
    def dtype(self): ...
    @property
    def chunks(self):  # -> None:
        ...
    @property
    def compression(self):  # -> Literal['gzip', 'lzf', 'szip'] | None:
        ...
    @property
    def compression_opts(self): ...
    @property
    def shuffle(self):  # -> bool:
        ...
    @property
    def fletcher32(self):  # -> bool:
        ...
    @property
    def scaleoffset(self):  # -> None:
        ...
    @property
    def external(self):  # -> list[Any] | None:
        ...
    @property
    def maxshape(self):  # -> tuple[Any | None, ...] | None:
        ...
    @property
    def fillvalue(self):  # -> Any:
        ...
    def __init__(self, bind, *, readonly=...) -> None: ...
    def resize(self, size, axis=...):  # -> None:
        ...
    def __len__(self): ...
    def len(self): ...
    def __iter__(self):  # -> Generator[Any, Any, None]:
        ...
    def iter_chunks(self, sel=...):  # -> ChunkIterator:
        ...
    def __getitem__(self, args, new_dtype=...): ...
    def __setitem__(self, args, val): ...
    def read_direct(self, dest, source_sel=..., dest_sel=...):  # -> None:
        ...
    def write_direct(self, source, source_sel=..., dest_sel=...):  # -> None:
        ...
    def __array__(self, dtype=..., copy=...):  # -> _Array1D[float64]:
        ...
    def __repr__(self):  # -> str:
        ...
    def refresh(self):  # -> None:
        ...
    def flush(self):  # -> None:
        ...
    @property
    def is_virtual(self): ...
    def virtual_sources(self):  # -> list[VDSmap]:
        ...
    def make_scale(self, name=...):  # -> None:
        ...
    @property
    def is_scale(self): ...
